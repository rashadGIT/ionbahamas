{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.positionFromDate = exports.startsBefore = undefined;\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _event2 = require(\"./event\");\n\nObject.defineProperty(exports, \"startsBefore\", {\n  enumerable: true,\n  get: function get() {\n    return _event2.startsBefore;\n  }\n});\nObject.defineProperty(exports, \"positionFromDate\", {\n  enumerable: true,\n  get: function get() {\n    return _event2.positionFromDate;\n  }\n});\n\nvar _sortBy = require(\"lodash/sortBy\");\n\nvar _sortBy2 = _interopRequireDefault(_sortBy);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n/**\n * Return true if event a and b is considered to be on the same row.\n */\n\n\nfunction onSameRow(a, b) {\n  return (// Occupies the same start slot.\n    Math.abs(b.startSlot - a.startSlot) <= 30 || // A\"s start slot overlaps with b\"s end slot.\n    a.startSlot > b.startSlot && a.startSlot < b.endSlot\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy2.default)(events, [\"start\", function (e) {\n    return -e.end;\n  }]);\n  var sorted = [];\n\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i]; // Still inside this event, look for next.\n\n      if (event.end > test.start) {\n        continue;\n      } // We\"ve found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n\n\n      if (i > 0) {\n        var _sortedByTime$splice = sortedByTime.splice(i, 1),\n            _sortedByTime$splice2 = _slicedToArray(_sortedByTime$splice, 1),\n            _event = _sortedByTime$splice2[0];\n\n        sorted.push(_event);\n      } // We\"ve already found the next event group, so stop looking.\n\n\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref) {\n  var events = _ref.events,\n      props = _objectWithoutProperties(_ref, [\"events\"]); // Create proxy events and order them so that we don\"t have\n  // to fiddle with z-indexes.\n\n\n  var proxies = events.map(function (event) {\n    return new _event2.Event(event, props);\n  });\n  var eventsInRenderOrder = sortByRender(proxies); // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i]; // Check if this event can go into a container event.\n\n    var container = containerEvents.find(function (c) {\n      return c.endSlot > event.startSlot;\n    }); // Couldn\"t find a container — that means this event is a container.\n\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return \"continue\";\n    } // Found a container for the event.\n\n\n    event.container = container; // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n\n    var row = null;\n\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn\"t find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  } // Return the original events, along with their styles.\n\n\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: event.xOffset\n      }\n    };\n  });\n}\n\nexports.default = getStyledEvents;","map":null,"metadata":{},"sourceType":"script"}