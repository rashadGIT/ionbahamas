{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.isEvent = isEvent;\nexports.objectsCollide = objectsCollide;\nexports.getBoundsForNode = getBoundsForNode;\n\nvar _contains = require(\"dom-helpers/query/contains\");\n\nvar _contains2 = _interopRequireDefault(_contains);\n\nvar _closest = require(\"dom-helpers/query/closest\");\n\nvar _closest2 = _interopRequireDefault(_closest);\n\nvar _events = require(\"dom-helpers/events\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _calendar = require(\"./calendar.scss\");\n\nvar _calendar2 = _interopRequireDefault(_calendar);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction addEventListener(type, handler) {\n  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;\n\n  _events2.default.on(target, type, handler);\n\n  return {\n    remove: function remove() {\n      _events2.default.off(target, type, handler);\n    }\n  };\n}\n\nfunction isOverContainer(container, x, y) {\n  return !container || (0, _contains2.default)(container, document.elementFromPoint(x, y));\n}\n\nfunction isEvent(node, _ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  var target = document.elementFromPoint(clientX, clientY);\n  return !!(0, _closest2.default)(target, _calendar2.default.rbcEvent, node);\n}\n\nfunction getEventCoordinates(e) {\n  var target = e;\n\n  if (e.touches && e.touches.length) {\n    target = e.touches[0];\n  }\n\n  return {\n    clientX: target.clientX,\n    clientY: target.clientY,\n    pageX: target.pageX,\n    pageY: target.pageY\n  };\n}\n\nvar clickTolerance = 5;\nvar clickInterval = 250;\n\nvar Selection = function () {\n  function Selection(node) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$global = _ref2.global,\n        global = _ref2$global === undefined ? false : _ref2$global,\n        _ref2$longPressThresh = _ref2.longPressThreshold,\n        longPressThreshold = _ref2$longPressThresh === undefined ? 250 : _ref2$longPressThresh;\n\n    _classCallCheck(this, Selection);\n\n    this.container = node;\n    this.globalMouse = !node || global;\n    this.longPressThreshold = longPressThreshold;\n    this._listeners = Object.create(null);\n    this._handleInitialEvent = this._handleInitialEvent.bind(this);\n    this._handleMoveEvent = this._handleMoveEvent.bind(this);\n    this._handleTerminatingEvent = this._handleTerminatingEvent.bind(this);\n    this._keyListener = this._keyListener.bind(this); // Fixes an iOS 10 bug where scrolling could not be prevented on the window.\n    // https://github.com/metafizzy/flickity/issues/457#issuecomment-254501356\n\n    this._onTouchMoveWindowListener = addEventListener(\"touchmove\", function () {}, window);\n    this._onKeyDownListener = addEventListener(\"keydown\", this._keyListener);\n    this._onKeyUpListener = addEventListener(\"keyup\", this._keyListener);\n\n    this._addInitialEventListener();\n  }\n\n  _createClass(Selection, [{\n    key: \"on\",\n    value: function on(type, handler) {\n      var handlers = this._listeners[type] || (this._listeners[type] = []);\n      handlers.push(handler);\n      return {\n        remove: function remove() {\n          var idx = handlers.indexOf(handler);\n\n          if (idx !== -1) {\n            handlers.splice(idx, 1);\n          }\n        }\n      };\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(type) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var result = void 0;\n      var handlers = this._listeners[type] || [];\n      handlers.forEach(function (fn) {\n        if (result === undefined) {\n          result = fn.apply(undefined, args);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      this.listeners = Object.create(null);\n      this._onTouchMoveWindowListener && this._onTouchMoveWindowListener.remove();\n      this._onInitialEventListener && this._onInitialEventListener.remove();\n      this._onEndListener && this._onEndListener.remove();\n      this._onMoveListener && this._onMoveListener.remove();\n      this._onKeyUpListener && this._onKeyUpListener.remove();\n      this._onKeyDownListener && this._onKeyDownListener.remove();\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected(node) {\n      var box = this._selectRect;\n\n      if (!box || !this.selecting) {\n        return false;\n      }\n\n      return objectsCollide(box, getBoundsForNode(node));\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(items) {\n      var box = this._selectRect; //not selecting\n\n      if (!box || !this.selecting) {\n        return [];\n      }\n\n      return items.filter(this.isSelected, this);\n    } // Adds a listener that will call the handler only after the user has pressed on the screen\n    // without moving their finger for 250ms.\n\n  }, {\n    key: \"_addLongPressListener\",\n    value: function _addLongPressListener(handler, initialEvent) {\n      var _this = this;\n\n      var timer = null;\n      var touchMoveListener = null;\n      var touchEndListener = null;\n\n      var handleTouchStart = function handleTouchStart(initialEvent) {\n        timer = setTimeout(function () {\n          cleanup();\n          handler(initialEvent);\n        }, _this.longPressThreshold);\n        touchMoveListener = addEventListener(\"touchmove\", function () {\n          return cleanup();\n        });\n        touchEndListener = addEventListener(\"touchend\", function () {\n          return cleanup();\n        });\n      };\n\n      var touchStartListener = addEventListener(\"touchstart\", handleTouchStart);\n\n      var cleanup = function cleanup() {\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        if (touchMoveListener) {\n          touchMoveListener.remove();\n        }\n\n        if (touchEndListener) {\n          touchEndListener.remove();\n        }\n\n        timer = null;\n        touchMoveListener = null;\n        touchEndListener = null;\n      };\n\n      if (initialEvent) {\n        handleTouchStart(initialEvent);\n      }\n\n      return {\n        remove: function remove() {\n          cleanup();\n          touchStartListener.remove();\n        }\n      };\n    } // Listen for mousedown and touchstart events. When one is received, disable the other and setup\n    // future event handling based on the type of event.\n\n  }, {\n    key: \"_addInitialEventListener\",\n    value: function _addInitialEventListener() {\n      var _this2 = this;\n\n      var mouseDownListener = addEventListener(\"mousedown\", function (e) {\n        _this2._onInitialEventListener.remove();\n\n        _this2._handleInitialEvent(e);\n\n        _this2._onInitialEventListener = addEventListener(\"mousedown\", _this2._handleInitialEvent);\n      });\n      var touchStartListener = addEventListener(\"touchstart\", function (e) {\n        _this2._onInitialEventListener.remove();\n\n        _this2._onInitialEventListener = _this2._addLongPressListener(_this2._handleInitialEvent, e);\n      });\n      this._onInitialEventListener = {\n        remove: function remove() {\n          mouseDownListener.remove();\n          touchStartListener.remove();\n        }\n      };\n    }\n  }, {\n    key: \"_handleInitialEvent\",\n    value: function _handleInitialEvent(e) {\n      var _getEventCoordinates = getEventCoordinates(e),\n          clientX = _getEventCoordinates.clientX,\n          clientY = _getEventCoordinates.clientY,\n          pageX = _getEventCoordinates.pageX,\n          pageY = _getEventCoordinates.pageY;\n\n      var node = this.container();\n      var collides = void 0;\n      var offsetData = void 0; // Right clicks\n\n      if (e.which === 3 || e.button === 2 || !isOverContainer(node, clientX, clientY)) {\n        return;\n      }\n\n      if (!this.globalMouse && node && !(0, _contains2.default)(node, e.target)) {\n        var _normalizeDistance = normalizeDistance(0),\n            top = _normalizeDistance.top,\n            left = _normalizeDistance.left,\n            bottom = _normalizeDistance.bottom,\n            right = _normalizeDistance.right;\n\n        offsetData = getBoundsForNode(node);\n        collides = objectsCollide({\n          top: offsetData.top - top,\n          left: offsetData.left - left,\n          bottom: offsetData.bottom + bottom,\n          right: offsetData.right + right\n        }, {\n          top: pageY,\n          left: pageX\n        });\n\n        if (!collides) {\n          return;\n        }\n      }\n\n      var result = this.emit(\"beforeSelect\", this._initialEventData = {\n        isTouch: /^touch/.test(e.type),\n        x: pageX,\n        y: pageY,\n        clientX: clientX,\n        clientY: clientY\n      });\n\n      if (result === false) {\n        return;\n      }\n\n      switch (e.type) {\n        case \"mousedown\":\n          this._onEndListener = addEventListener(\"mouseup\", this._handleTerminatingEvent);\n          this._onMoveListener = addEventListener(\"mousemove\", this._handleMoveEvent);\n          break;\n\n        case \"touchstart\":\n          this._handleMoveEvent(e);\n\n          this._onEndListener = addEventListener(\"touchend\", this._handleTerminatingEvent);\n          this._onMoveListener = addEventListener(\"touchmove\", this._handleMoveEvent);\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"_handleTerminatingEvent\",\n    value: function _handleTerminatingEvent(e) {\n      var _getEventCoordinates2 = getEventCoordinates(e),\n          pageX = _getEventCoordinates2.pageX,\n          pageY = _getEventCoordinates2.pageY;\n\n      this.selecting = false;\n      this._onEndListener && this._onEndListener.remove();\n      this._onMoveListener && this._onMoveListener.remove();\n\n      if (!this._initialEventData) {\n        return;\n      }\n\n      var inRoot = !this.container || (0, _contains2.default)(this.container(), e.target);\n      var bounds = this._selectRect;\n      var click = this.isClick(pageX, pageY);\n      this._initialEventData = null;\n\n      if (click && !inRoot) {\n        return this.emit(\"reset\");\n      }\n\n      if (click && inRoot) {\n        return this._handleClickEvent(e);\n      } // User drag-clicked in the Selectable area\n\n\n      if (!click) {\n        return this.emit(\"select\", bounds);\n      }\n    }\n  }, {\n    key: \"_handleClickEvent\",\n    value: function _handleClickEvent(e) {\n      var _getEventCoordinates3 = getEventCoordinates(e),\n          pageX = _getEventCoordinates3.pageX,\n          pageY = _getEventCoordinates3.pageY,\n          clientX = _getEventCoordinates3.clientX,\n          clientY = _getEventCoordinates3.clientY;\n\n      var now = new Date().getTime();\n\n      if (this._lastClickData && now - this._lastClickData.timestamp < clickInterval) {\n        // Double click event\n        this._lastClickData = null;\n        return this.emit(\"doubleClick\", {\n          x: pageX,\n          y: pageY,\n          clientX: clientX,\n          clientY: clientY\n        });\n      } // Click event\n\n\n      this._lastClickData = {\n        timestamp: now\n      };\n      return this.emit(\"click\", {\n        x: pageX,\n        y: pageY,\n        clientX: clientX,\n        clientY: clientY\n      });\n    }\n  }, {\n    key: \"_handleMoveEvent\",\n    value: function _handleMoveEvent(e) {\n      var _initialEventData = this._initialEventData,\n          x = _initialEventData.x,\n          y = _initialEventData.y;\n\n      var _getEventCoordinates4 = getEventCoordinates(e),\n          pageX = _getEventCoordinates4.pageX,\n          pageY = _getEventCoordinates4.pageY;\n\n      var w = Math.abs(x - pageX);\n      var h = Math.abs(y - pageY);\n      var left = Math.min(pageX, x);\n      var top = Math.min(pageY, y);\n      var old = this.selecting;\n      this.selecting = true;\n      this._selectRect = {\n        top: top,\n        left: left,\n        x: pageX,\n        y: pageY,\n        right: left + w,\n        bottom: top + h\n      };\n\n      if (!old) {\n        this.emit(\"selectStart\", this._initialEventData);\n      }\n\n      if (!this.isClick(pageX, pageY)) {\n        this.emit(\"selecting\", this._selectRect);\n      }\n\n      e.preventDefault();\n    }\n  }, {\n    key: \"_keyListener\",\n    value: function _keyListener(e) {\n      this.ctrl = e.metaKey || e.ctrlKey;\n    }\n  }, {\n    key: \"isClick\",\n    value: function isClick(pageX, pageY) {\n      var _initialEventData2 = this._initialEventData,\n          x = _initialEventData2.x,\n          y = _initialEventData2.y,\n          isTouch = _initialEventData2.isTouch;\n      return !isTouch && Math.abs(pageX - x) <= clickTolerance && Math.abs(pageY - y) <= clickTolerance;\n    }\n  }]);\n\n  return Selection;\n}();\n/**\n * Resolve the disance prop from either an Int or an Object\n * @return {Object}\n */\n\n\nfunction normalizeDistance() {\n  var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n  if ((typeof distance === \"undefined\" ? \"undefined\" : _typeof(distance)) !== \"object\") {\n    distance = {\n      top: distance,\n      left: distance,\n      right: distance,\n      bottom: distance\n    };\n  }\n\n  return distance;\n}\n/**\n * Given two objects containing \"top\", \"left\", \"offsetWidth\" and \"offsetHeight\"\n * properties, determine if they collide.\n * @return {bool}\n */\n\n\nfunction objectsCollide(nodeA, nodeB) {\n  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  var _getBoundsForNode = getBoundsForNode(nodeA),\n      aTop = _getBoundsForNode.top,\n      aLeft = _getBoundsForNode.left,\n      _getBoundsForNode$rig = _getBoundsForNode.right,\n      aRight = _getBoundsForNode$rig === undefined ? aLeft : _getBoundsForNode$rig,\n      _getBoundsForNode$bot = _getBoundsForNode.bottom,\n      aBottom = _getBoundsForNode$bot === undefined ? aTop : _getBoundsForNode$bot;\n\n  var _getBoundsForNode2 = getBoundsForNode(nodeB),\n      bTop = _getBoundsForNode2.top,\n      bLeft = _getBoundsForNode2.left,\n      _getBoundsForNode2$ri = _getBoundsForNode2.right,\n      bRight = _getBoundsForNode2$ri === undefined ? bLeft : _getBoundsForNode2$ri,\n      _getBoundsForNode2$bo = _getBoundsForNode2.bottom,\n      bBottom = _getBoundsForNode2$bo === undefined ? bTop : _getBoundsForNode2$bo; // \"a\" bottom doesn\"t touch \"b\" top\n\n\n  return !(aBottom - tolerance < bTop || // \"a\" top doesn\"t touch \"b\" bottom\n  aTop + tolerance > bBottom || // \"a\" right doesn\"t touch \"b\" left\n  aRight - tolerance < bLeft || // \"a\" left doesn\"t touch \"b\" right\n  aLeft + tolerance > bRight);\n}\n/**\n * Given a node, get everything needed to calculate its boundaries\n * @param  {HTMLElement} node\n * @return {Object}\n */\n\n\nfunction getBoundsForNode(node) {\n  if (!node.getBoundingClientRect) {\n    return node;\n  }\n\n  var rect = node.getBoundingClientRect();\n  var left = rect.left + pageOffset(\"left\");\n  var top = rect.top + pageOffset(\"top\");\n  return {\n    top: top,\n    left: left,\n    right: (node.offsetWidth || 0) + left,\n    bottom: (node.offsetHeight || 0) + top\n  };\n}\n\nfunction pageOffset(dir) {\n  if (dir === \"left\") {\n    return window.pageXOffset || document.body.scrollLeft || 0;\n  }\n\n  if (dir === \"top\") {\n    return window.pageYOffset || document.body.scrollTop || 0;\n  }\n}\n\nexports.default = Selection;","map":null,"metadata":{},"sourceType":"script"}